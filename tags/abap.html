<!DOCTYPE html><html lang="ru"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="Nosoff.info — personal blog"/><title>Nosoff.info #abap</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/6a76aa4579e9e08b9326.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6a76aa4579e9e08b9326.css" data-n-g=""/><link rel="preload" href="/_next/static/css/660f735cfd0633f1a2b3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/660f735cfd0633f1a2b3.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-6957307470fcc6d1f962.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9ec1f7868b3e9d138cdd.js" as="script"/><link rel="preload" href="/_next/static/chunks/022a8770.bca366718f045dbe8189.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.cb82874e43d6dd0d0fae.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-934682e3295d5f8e18d6.js" as="script"/><link rel="preload" href="/_next/static/chunks/bc82bb883724fe5faad984d18f20974d5cb6d361.2871a84b50d924fb6d88.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/tags/%5Btag%5D-28483c73561c85fc62a3.js" as="script"/></head><body><div id="__next"><div class="min-h-screen"><main><div class="container mx-auto px-5"><section class="flex-col md:flex-row flex items-center md:justify-between mt-16 mb-16 md:mb-12"><h1 class="text-6xl md:text-8xl font-bold tracking-tighter leading-tight md:pr-8">Nosoff.info <!-- -->abap</h1></section><section><div class="mb-8 md:mb-16"><div class="-mx-5 sm:mx-0"><a aria-label="Ищем, в каких таблицах используется домен в ABAP" href="/posts/domain_where_used_list"><img src="/assets/blog/domain_where_used_list/background.jpg" alt="Cover Image for Ищем, в каких таблицах используется домен в ABAP" class="shadow-small hover:shadow-medium transition-shadow duration-200"/></a></div></div><div class="md:col-gap-16 lg:col-gap-8 mb-20 md:mb-28"><div><h3 class="screenreader"><a class="hover:underline" href="/posts/domain_where_used_list">Ищем, в каких таблицах используется домен в ABAP</a></h3><div class="mb-4 md:mb-0 text-lg"><time dateTime="2020-07-12T14:15:07.322Z">July	12, 2020</time></div></div><div><p class="text-lg leading-relaxed mb-4">Пишем удобную утилиту, которая позволит найти, в каких таблицах БД используется выбранный домен и вычислить количество в них строк</p><a class="flex items-center" href="https://github.com/JustAddAcid"><img src="https://avatars3.githubusercontent.com/u/21103635?s=120&amp;v=4" class="w-12 h-12 rounded-full mr-4" alt="Roman A. Nosov"/><div class="text-xl font-bold">Roman A. Nosov</div></a></div></div></section><section><h2 class="mb-8 text-6xl md:text-7xl font-bold tracking-tighter leading-tight">More Stories</h2><div class="grid grid-cols-1 md:grid-cols-2 md:col-gap-16 lg:col-gap-32 row-gap-20 md:row-gap-32 mb-32"><div><div class="mb-5"><div class="-mx-5 sm:mx-0"><a aria-label="Класс для удобного манипулирования датами в ABAP" href="/posts/zcl-date-abap"><img src="/assets/blog/zcl_date_abap/cover.png" alt="Cover Image for Класс для удобного манипулирования датами в ABAP" class="shadow-small hover:shadow-medium transition-shadow duration-200"/></a></div></div><h3 class="screenreader"><a class="hover:underline" href="/posts/zcl-date-abap">Класс для удобного манипулирования датами в ABAP</a></h3><div class="text-lg mb-4"><time dateTime="2020-05-24T14:15:07.322Z">May	24, 2020</time></div><p class="text-lg leading-relaxed mb-4">Надоело страдать с парсингом стандартных типов даты в abap и использовать громоздкие функциональные модули. Написал класс для выполнения рутинных действий в удобном API</p><a class="flex items-center" href="https://github.com/JustAddAcid"><img src="https://avatars3.githubusercontent.com/u/21103635?s=120&amp;v=4" class="w-12 h-12 rounded-full mr-4" alt="Roman A. Nosov"/><div class="text-xl font-bold">Roman A. Nosov</div></a></div></div></section></div></main></div><footer class="bg-accent-1 border-t border-accent-2"><div class="container mx-auto px-5"></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"allPosts":[{"title":"Ищем, в каких таблицах используется домен в ABAP","date":"2020-07-12T14:15:07.322Z","slug":"domain_where_used_list","author":{"name":"Roman A. Nosov","picture":"https://avatars3.githubusercontent.com/u/21103635?s=120\u0026v=4","url":"https://github.com/JustAddAcid"},"content":"\nКакое здесь может быть введение? Продолжаю писать образовательные посты с небольшими вкраплениями абсурда, мемов и ненависти ко всему окружающему. Сегодня пишем утилиту. Под *SAP*. Своё отношение к разработке на этой платформе высказывал в [предыдущей статье](./zcl-date-abap).\n\nКонкретно эта программа — очень хороший пример, как сама система вынуждает разработчиков усложнять код и делать костыли, чтобы обойти абсолютно **искусственно** расставленные ограничения. Усаживайтесь поудобнее, мы начинаем!\n\n![Девайсы для abap'еров](/assets/blog/domain_where_used_list/device.jpg)\n\n## Немного теории\n\n**Що таке домени в *SAP*?**\n\n**Домены в SAP** — это то, что ~~нормальные~~ люди называют *типами данных*. То, как данные представлены непосредственно в памяти программы или *СУБД*: строка из N символов, int32, int64, float, enum из определенного набора значений и т.д.\n\nЕсть ещё такое понятие в *SAP*-тусовке как **элемент данных** (*data element*). Это \"тип данных на максималках\", который содержит в себе **не только** описание того, как эти данные лежат в памяти, но и дополнительные плюшки в виде:\n\n1. Дефолтный заголовок этого поля для разных языков (который подтягивается в поле ввода или заголовок таблицы по умолчанию)\n2. Ссылка на \"средство поиска\" — программу, которая помогает пользователю заполнить input значением. (Например, предоставить выбор из списка контрагентов с заданными параметрами)\n3. ... прочие второстепенные штуки\n\nТ.е. сначала объявляется домен, от него наследуется элемент данных, который уже используется для объявления переменных/объявления столбцов в таблицах БД.\n\n![Схема наследования](/assets/blog/domain_where_used_list/data_element.jpg)\n\nОукей, на первых парах нам этой информации достаточно. Остальное будем понимать по ходу процесса:\n\n## Процесс \n\n**Формулируем**, что мы хотим получить в итоге. Программу, которая:\n\n1. Принимает на вход **имя домена** и параметр:\n   1. Считать ли количество строк в таблицах\n2. Выводит список таблиц со следующими полями:\n   1. Имя таблицы, которая использует введенный домен\n   2. Название поля таблицы\n   3. Имя элемента данных этого поля\n   4. Количество строк **или** результат проверки на пустоту (в зависимости от входного параметра) \n\nНа самом деле, 95% этой задачи решаются очень быстро. Достаточно найти место в базе данных, где хранятся соответствия таблицы -\u003e типа данных -\u003e домена и сделать селект. (Благо, в БД SAP хранится **ВСЁ**, включая программный код)\n\nМетодом скоростного гугления обнаруживаем две таблицы, которые нам в этом могут помочь:\n\n1. **dd03l** — соответствие: таблица - поле - тип данных - домен\n2. **dd02l** — соответствие: таблица - класс таблицы (нас не интересуют объявленные типы таблиц, которые **не** используются в БД)\n\nНу и простейший селект из них:\n\n```abap\nSELECT DISTINCT dd03l~domname dd03l~rollname dd03l~fieldname\n    dd03l~tabname\n  INTO CORRESPONDING FIELDS OF TABLE rt_tables\n  FROM dd03l JOIN dd02l\n    ON dd03l~tabname = dd02l~tabname AND\n      dd03l~as4local = dd02l~as4local\n  WHERE\n    dd03l~domname IN ir_domains AND\n    \" Активные\n    dd03l~as4local = 'A' AND\n    \" Таблицы, которые используются в СУБД\n    dd02l~tabclass IN ('TRANSP', 'CLUSTER', 'POOL').\n```\n\nПроверка количества записей делается самым очевидным способом: **select count(\\*)** в цикле по всем таблицам.\n\n```abap\nLOOP AT lt_tables ASSIGNING \u003cls_table\u003e.\n  SELECT SINGLE COUNT(*)\n    FROM (\u003cls_table\u003e-tabname)\n    INTO lv_records_count.\n\n  \" [ .... ]\nENDLOOP.\n```\n\nКазалось бы, что может пойти не так? Всего лишь осталось реализовать проверку таблицы на пустоту, не делая select count(\\*) по всей таблице. \n\nПоскольку за выполнение запросов напрямую в **БД**, минуя прослойку **ABAP** — абаперов бьют по рукам (особенно при миграции на другую *СУБД*). Разработчикам приходится довольствоваться куцым подмножеством **sql**, который предоставляет ABAP API. В нём напрочь отсутствует не только *database-specific-features*, но и вполне стандартные вещи типа вложенных запросов.\n\nТ.е. вот такой простой и понятный запрос у нас ни за что не выполнится:\n```sql\nselect count(*) \nfrom (select top 1 * \n      from TABLE)\n```\n\nПриходится изобретать велосипед. И единственным выходом в этой ситуации будет попытка сделать селект **хотя бы одной** записи из таблицы и проверка на успех.\n\nСказано-сделано:\n```abap\nLOOP AT lt_tables ASSIGNING \u003cls_table\u003e.\n  SELECT SINGLE *\n    FROM (\u003cls_table\u003e-tabname)\n    INTO \" ...\n  \" Так, стоп. А куда присваивать значение?\n  \" [ .... ]\nENDLOOP.\n```\n\nБлок **into %var%** пропустить нельзя. Без него компиллятор сваливается с ошибкой. (Про ABAP-подобие байткода как-нибудь в другой раз)\n\nА куда присваивать значения, если заранее неизвестен тип данных? В **ABAP** таких \"безразмерных\" типов нет. Так что придется как-то объявлять переменные в рантайме. Но с этим не всё так гладко! :)\n\n## Длинное отступление про принцип объявления переменных в ABAP\n\nКазалось бы, о чем здесь рассказывать? Почти каждый относительно-высокоуровневый язык предоставляет очень простой *API* для объявления переменных. \n\nВ данном случае, переменные объявляются ключевым словом **DATA**, далее идет указание имени переменной и её тип:\n```abap\ndata some_name type string.\n```\n\nНо, поскольку *abap* — достаточно старый язык, он тянет за собой весьма странное легаси-поведение, которое в современном мире кажется моветоном. Например:\n```abap\nif 1 = 1.\n    data some_string type string.\n    some_string = 'hello world'.\nendif.\n\nwrite some_string.\n```\nУважаемые знатоки, внимание вопрос: выполнится ли этот код без ошибки? И выведется ли *hello world?*\u003cbr\u003e\nПравильные ответы: **да и да**.\n\nЕсли вы на секунду подумали, что объявление переменных в *abap* ведет себя так же, как ключевое слово **var** в *JavaScript*, и переменная *\"вываливается\"* за текущий блок, то спешу вас разочаровать... \n```abap\nif 1 = 2.\n    \" Никогда не выполнится\n    data some_string type string.\nendif.\n\nsome_string = 'hello world'.\nwrite some_string. \"hello world \n\"(да, это работает)\n```\n\nНесмотря на то, что выполнение основного интерпретатора программы **никогда** не зайдёт в блок **IF**, переменная всё равно объявится!\n\n**N.B.**: перед выполнением кода, его быстренько пробегает интерпретатор и выделяет память под **все** используемые переменные в этой подпрограмме/методе.\n\nА объявленные переменные будут доступны в **любом месте** внутри метода/подпрограммы.\n\nНа самом деле, это больше похоже на хостинг функций в *JavaScript*. [Который хорошо описан здесь.](https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%9F%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5)\n\nЗначит ли это, ~~что всё предопределено~~ что мы не можем выделять память в рантайме, когда на момент компилляции неизвестен тип? \n\nИ да, и нет. Саму переменную всё-таки придется объявить в виде ссылки на \"какую-то\" область памяти. А под неё уточнить тип и выделить память мы можем тогда, когда нам это потребуется. Выглядит это следующим образом:\n```abap\n\" Создаём переменную как ссылку на \"какие-то\" данные\ndata my_var type ref to data.\n\" Выделяем память под нужный тип данных\ncreate data my_var type ('typename').\n```\n\nЭто, конечно, прекрасно. Но так просто обращаться к этой области памяти и записывать/читать данные у нас не получится! :) Для этого нам потребуется познакомиться с ещё одним abap-концептом.\n\nЭто **field-symbols** — ссылки на уже **объявленные** переменные или строки таблицы. В примерах выше, где я делал цикл по таблице, я уже использовал *field-symbol*, куда присваивал адрес \"текущей\" строки в итерации цикла.\n\n```abap\nloop at table assigning \u003cfield-symbol\u003e.\n\" do some shit with \u003cfield-symbol\u003e\nendloop.\n```\n\nАналогичное действие придется выполнить и сейчас, чтобы полноценно воспользоваться выделенной памятью, как переменной:\n\n```abap\ndata my_var type ref to data.\n\" field-symbol можно объявлять с типом any\nfield-symbols \u003clink_to_data\u003e type any.\n\ncreate data my_var type ('typename').\nassign my_var-\u003e* to \u003clink_to_data\u003e.\n\n\" do some shit with \u003clink_to_data\u003e\n```\n\n## Финишная прямая:\n\nПрикручиваем эти концепты к нашей задаче:\n\n```abap\nFIELD-SYMBOLS: \u003clv_temp\u003e  TYPE ANY.\nDATA lo_data TYPE REF TO data.\n\nLOOP AT it_tables ASSIGNING \u003cls_table\u003e.\n  \n  CREATE DATA lo_data TYPE (\u003cls_table\u003e-rollname).\n  ASSIGN lo_data-\u003e* TO \u003clv_temp\u003e.\n\n  SELECT SINGLE (\u003cls_table\u003e-fieldname)\n    FROM (\u003cls_table\u003e-tabname)\n    INTO \u003clv_temp\u003e.\n\n  \"sy-subrc аналог return-code в bash\n  IF sy-subrc = 0.\n    \" Обработка успешного селекта\n  ELSE.\n    \" Обработка пустой таблицы\n  ENDIF.\nENDLOOP.\n```\n\n## Заключение\n\nВнезапно этот костыль компилируется и работает. За очисткой данных можно не следить, т.к. за нас её выполнит сборщик мусора. Нам остаётся красиво нарисовать результаты пользователю, но это уже совсем другая история.\n\nВот именно таким образом тривиальные задачи усложняются внутри abap во много раз из-за излишних синтаксических ограничений. \n\nНапример, если бы было возможно выполнить вложенный *sql* или исключить блок \"into\" в запросах, то не пришлось бы в цикле выделять много памяти под абсолютно ненужную переменную, которая никак не обрабатывается в дальнейшем. \n\n(Кстати, создавая потенциальную утечку памяти, т.к. никто не знает, насколько качественно отрабатывает сборщик мусора)\n\nНа этом всё. Всех благ. :)\n\n#abap","ogImage":{"url":"/assets/blog/domain_where_used_list/background.jpg"},"coverImage":"/assets/blog/domain_where_used_list/background.jpg","issueId":"13","excerpt":"Пишем удобную утилиту, которая позволит найти, в каких таблицах БД используется выбранный домен и вычислить количество в них строк"},{"title":"Класс для удобного манипулирования датами в ABAP","date":"2020-05-24T14:15:07.322Z","slug":"zcl-date-abap","author":{"name":"Roman A. Nosov","picture":"https://avatars3.githubusercontent.com/u/21103635?s=120\u0026v=4","url":"https://github.com/JustAddAcid"},"content":"\nНастало время делиться своей болью и страданиями. Меня зовут Носов Роман, и, мне очень стыдно в этом признаться, но я ~~алкоголик~~ иногда пишу на *ABAP*, чтобы не умереть с голоду.\n\n**Для тех, кто в танке и никогда не слышал, что это такое:** *ABAP* — это внутренний язык, на котором программируют (допиливают напильником) разные продукты от *SAP* . От допиливаний страдают, как сама система, так и программисты с пользователями. И всё действо со стороны больше напоминает истязания грешников в каком-нибудь круге ада по Данте.\n\nА **SAP** в свою очередь — ~~очень дорогая немецкая одинэска~~ компания которая делает ERP системы для крупных бизнесов.\n\nКак сказал неизвестный мудрец в комментариях на хабре:\n![SAP — это месть Гитлера за Сталинград](/assets/blog/zcl_date_abap/stalingrad.png)\n\n## И тут мне захотелось немного уменьшить градус боли (по части работы с датами)\n\n### Для начала немного теории:\n\nВ *ABAP* для хранения даты встроен специальный тип данных — *DATS* (или сокращенно — *D*). Представляет он из себя строку из 8 символов, в которой хранится по порядку: год,месяц,день. \n\n**Например:** '20190102' — это второе января 2019 года.\n\nТак же, для этого типа данных перегружены действия + и -. Которые отнимают и прибавляют дни к дате, или считают разницу в днях между двумя датами.\n\n```abap\nDATA: lv_dats  TYPE dats,\n      lv_dats2 TYPE dats,\n      lv_int   TYPE i.\n\n\" -/+ между dats и int возвращает dats с отнятыми/прибавленными днями\nlv_dats = '20190102'.\nlv_dats = lv_dats - 5.\nWRITE lv_dats. \" 28.12.2018\n\n\" -/+ между dats и dats возвращает int — разница между датами в днях\nlv_dats2 = '20190101'.\nlv_int = lv_dats2 - lv_dats. \" 01.01.2019 -  28.12.2018\nWRITE lv_int. \" 4\n```\n\nНо что делать, если очень хочется сделать инкремент месяца (не + 30 дней, а именно получить то же число следующего месяца, независимо от длины месяца (28-31))?\n\nДля этого есть громоздкий функциональный модуль RP_CALC_DATE_IN_INTERVAL. Умеет складывать/отнимать годы/месяцы/дни и возвращает валидную дату. \n\n```abap\nDATA: lv_dats  TYPE dats.\n\nlv_dats = '20190215'. \" 15.02.2019\n\nCALL FUNCTION 'RP_CALC_DATE_IN_INTERVAL'\n  EXPORTING\n    date      = lv_dats\n    days      = 0\n    months    = 1\n    signum    = '+'\n    years     = 0\n  IMPORTING\n    calc_date = lv_dats.\n\nwrite lv_dats. \" Искомое 15 марта\n```\n\nНо вы точно хотите использовать в своих программах вот такие уродливые конструкции?\n\nОтдельным пунктиком следует упомянуть про развлечения программистов с красивым форматированием даты. Огромные полотна кода с выдёргиваниями подстрок из даты, и конкатенации в нормальном виде.\n[Пример](https://www.erpworkbench.com/abap/date/date_format.htm \"Formatting SAP date field using ABAP\")\n\nА если очень хочется вместо номера месяца видеть его название? Май, апрель....\n\nА если очень хочется видеть названия месяцев на том языке, на котором запущен SAP? :)\nОгромные просторы для танцев с бубном и изобретаний велосипедов!\n\n## Z* разработки в SAP — бесконечная фабрика велосипедов\n![worst programming language](/assets/blog/zcl_date_abap/meme.jpg)\n\nИтак, нам нужен класс, который мог инкапсулировать в себе стандартный dats, но предоставлять удобный *API* для работы с датами, максимально скрывая уродливость языка *ABAP*.\n\nОн должен уметь:\n\n1. Прибавлять дни/месяцы/годы к текущей дате\n2. Иметь адекватные геттеры/сеттеры для дней/месяцев/годов, скрывая работу с подстроками\n3. Получать названия месяцев на заданном языке\n4. Метод *to_string*, который возвращает строковое представление даты по заданной маске *(like printf)*\n\n## Реализация:\n\nСоздаём класс. В его свойствах будем хранить:\n\n1. Язык, который будет передаваться в конструкторе — (по умолчанию — язык системы)\n2. Дата, которая аналогично будет передаваться в конструкторе — (по умолчанию — текущая)\n3. Таблица названий месяцев для выбранного пользователем языка\n4. Константы для метода to_string( )\n\n```abap\n  DATA:\n    gt_month_names TYPE STANDARD TABLE OF t247 .\n  DATA gv_language TYPE lang .\n  DATA gv_date TYPE dats .\n  CONSTANTS nv_long_year TYPE string VALUE '$yyyy'.       \n  CONSTANTS nv_short_year TYPE string VALUE '$yy'.        \n  CONSTANTS nv_month_name TYPE string VALUE '$m'.         \n  CONSTANTS nv_short_month_name TYPE string VALUE '$mmm'. \n  CONSTANTS nv_month_number TYPE string VALUE '$mm'.      \n  CONSTANTS nv_day TYPE string VALUE '$dd'.               \n```\n\n**Конструктор и статический метод create**\n\n```abap\n  \" Просто присваиваем значения \n  METHOD constructor.\n    gv_language = iv_language.\n    gv_date = iv_date.\n  ENDMETHOD.\n\n  METHOD create. \" Что-то отдалённо похожее на фабричный метод,\n  \" только возвращаем инстанс самого класса zcl_date. \n  \" Таким образом избавляемся от громоздкой конструкции create object*\n  \n    CREATE OBJECT ro_instance\n      EXPORTING\n        iv_date     = iv_date\n        iv_language = iv_language.\n  ENDMETHOD.\n```\n\nПрибавлять и вычитать будем уже известным функциональным модулем *RP_CALC_DATE_IN_INTERVAL*, но спрячем его поглубже, чтобы не было так страшно. Наружу (public) будут торчать два минималистичных метода: plus/minus\n\n```abap\n  METHOD date_calculation.\n    CALL FUNCTION 'RP_CALC_DATE_IN_INTERVAL'\n      EXPORTING\n        date      = gv_date\n        days      = iv_days\n        months    = iv_months\n        signum    = iv_sign\n        years     = iv_years\n      IMPORTING\n        calc_date = gv_date.\n  ENDMETHOD.\n\n  METHOD minus.\n    date_calculation( iv_days   = iv_days\n                      iv_months = iv_months\n                      iv_years  = iv_years\n                      iv_sign   = '-' ).\n  ENDMETHOD.\n\n  METHOD plus.\n    date_calculation( iv_days   = iv_days\n                      iv_months = iv_months\n                      iv_years  = iv_years\n                      iv_sign   = '+' ).\n  ENDMETHOD.\n```\n\nПолучать названия месяцев на текущем языке будем с помощью ФМ *MONTH_NAMES_GET*, который будем дёргать тогда, когда осознаем, что для этого языка у нас нет названий.\n\n```abap\n  METHOD init_month_names.\n    CALL FUNCTION 'MONTH_NAMES_GET'\n      EXPORTING\n        language              = gv_language\n      TABLES\n        month_names           = gt_month_names\n      EXCEPTIONS\n        month_names_not_found = 1\n        OTHERS                = 2.\n  ENDMETHOD.\n\n  METHOD get_month_name_by_number.\n    DATA ls_month LIKE LINE OF gt_month_names.\n  \n    \" Есть ли вообще записи для текущего языка?\n    READ TABLE gt_month_names\n      INTO ls_month\n      WITH KEY spras = gv_language.\n  \n    IF sy-subrc \u003c\u003e 0.\n      init_month_names( ).\n    ENDIF.\n  \n    CLEAR ls_month.\n    READ TABLE gt_month_names\n      INTO ls_month\n      WITH KEY\n        mnr   = iv_number\n        spras = gv_language.\n  \n    rv_month_name = ls_month-ltx.\n  ENDMETHOD.\n```\n\nНу и метод to_string( ). Который заменяет ключевые слова в маске значениями.\n\n```abap\n  METHOD to_string.\n    DATA:\n      lv_day              TYPE num2,\n      lv_month_name       TYPE string,\n      lv_month_number     TYPE num2,\n      lv_short_month_name TYPE string,\n      lv_short_year       TYPE num2,\n      lv_long_year        TYPE num4.\n\n    lv_day = get_day( ).\n    lv_month_name = get_month_name( ).\n    lv_month_number = get_month_number( ).\n    lv_short_month_name = get_short_month_name( ).\n    lv_short_year = get_short_year( ).\n    lv_long_year = get_year( ).\n\n    \" year\n    REPLACE ALL OCCURRENCES OF nv_long_year IN iv_format WITH lv_long_year IGNORING CASE.\n    REPLACE ALL OCCURRENCES OF nv_short_year IN iv_format WITH lv_short_year IGNORING CASE.\n\n    \" month\n    REPLACE ALL OCCURRENCES OF nv_short_month_name IN iv_format WITH lv_short_month_name IGNORING CASE.\n    REPLACE ALL OCCURRENCES OF nv_month_number IN iv_format WITH lv_month_number IGNORING CASE.\n    REPLACE ALL OCCURRENCES OF nv_month_name IN iv_format WITH lv_month_name IGNORING CASE.\n\n    \"day\n    REPLACE ALL OCCURRENCES OF nv_day IN iv_format WITH lv_day IGNORING CASE.\n\n    rv_string = iv_format.\n  ENDMETHOD.\n```\n\nОсталось прикрутить геттеры/сеттеры. и доработать API.\n\nЧто в итоге получилось — можно посмотреть здесь: [github.com/JustAddAcid/abap_date](https://github.com/JustAddAcid/abap_date/ \"Класс для удобного использования даты в abap\")\n\n## Результаты\n\n1. Минималистичные методы plus/minus\n\n```abap\nlo_date = zcl_date=\u003ecreate( '20200101' ). \" 01.01.2020\n\nlo_date-\u003eminus( iv_years = 2 ). \" 01.01.2018\nlo_date-\u003eplus( iv_days = 3 ).   \"04.01.2018\nlo_date-\u003eplus( iv_months = 1 ). \"04.02.2018\n\n\" Несколько аргументов\nlo_date-\u003eplus( \n    iv_days  = 1\n    iv_years = 2\n). \" 05.02.2020\n```\n\n2. Геттеры/сеттеры\n3. Метод get_month_name( ), получающий названия месяца\n\n```abap\ndata: lo_date  type ref to zcl_date,\n      lv_dats  type dats,\n      lv_month type string.\n\nlo_date = zcl_date=\u003ecreate( ).\nlo_date-\u003eset_year( 2001 ).\nlo_date-\u003eset_month_number( 9 ).\nlo_date-\u003eset_day( 11 ).\n\nlv_dats = lo_date-\u003eget_date( ).\nlv_month = lo_date-\u003eget_month_name( ).\n\nwrite lv_dats. \" 11 сентября 2001\nwrite lv_month. \" Сентябрь\n```\n\n4. Метод to_string( ), возвращающий строковое представление даты по маске\n \n```abap\ndata: lo_date     type ref to zcl_date,\n      lv_formated type string.\n\nlo_date = zcl_date=\u003ecreate( '20200101' ). \" 01.01.2020\nlv_formated = lo_date-\u003eto_string( 'Месяц: $m Год: $yyyy День: $dd' ).\n\nwrite lv_formated. \" Месяц: Январь Год: 2020 День: 01\n```\n\n#abap ","ogImage":{"url":"/assets/blog/zcl_date_abap/cover.png"},"coverImage":"/assets/blog/zcl_date_abap/cover.png","issueId":"8","excerpt":"Надоело страдать с парсингом стандартных типов даты в abap и использовать громоздкие функциональные модули. Написал класс для выполнения рутинных действий в удобном API"}],"tag":"abap"},"__N_SSG":true},"page":"/tags/[tag]","query":{"tag":"abap"},"buildId":"AU1i3o0OzRg5qbJU0O0jy","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-fa276ba060a4a8ac7eef.js"></script><script src="/_next/static/chunks/main-6957307470fcc6d1f962.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9ec1f7868b3e9d138cdd.js" async=""></script><script src="/_next/static/chunks/022a8770.bca366718f045dbe8189.js" async=""></script><script src="/_next/static/chunks/commons.cb82874e43d6dd0d0fae.js" async=""></script><script src="/_next/static/chunks/pages/_app-934682e3295d5f8e18d6.js" async=""></script><script src="/_next/static/chunks/bc82bb883724fe5faad984d18f20974d5cb6d361.2871a84b50d924fb6d88.js" async=""></script><script src="/_next/static/chunks/pages/tags/%5Btag%5D-28483c73561c85fc62a3.js" async=""></script><script src="/_next/static/AU1i3o0OzRg5qbJU0O0jy/_buildManifest.js" async=""></script><script src="/_next/static/AU1i3o0OzRg5qbJU0O0jy/_ssgManifest.js" async=""></script></body></html>